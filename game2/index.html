<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Space Shooter — Amblyopia Friendly</title>
<style>
  :root { --bg:#050712; --panel:#111; --accent:#07f; --muted:#9aa; color-scheme: dark; }
  body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:#eee; display:flex; flex-direction:column; align-items:center; padding:18px; }
  h1{margin:0 0 8px 0;font-size:20px}
  .wrap{max-width:1100px; width:100%; display:flex; gap:16px}
  canvas{background:#000; border-radius:8px; display:block; width:100%;}
  .left{flex:1}
  aside{width:320px; background:var(--panel); padding:12px; border-radius:8px; color:#ddd}
  label{display:block; font-size:13px; margin-top:10px}
  input[type=range]{width:100%}
  .controls{display:flex; gap:8px; margin-top:10px}
  button{background:var(--accent); color:#001; border:none; padding:8px 10px; border-radius:6px; cursor:pointer}
  .muted{color:var(--muted); font-size:13px}
  ul{padding-left:18px; margin:8px 0}
  .hud{display:flex; justify-content:space-between; margin-top:8px; font-weight:600}
  .small{font-size:13px}
</style>
</head>
<body>
  <h1>Space Shooter — Therapy Mode</h1>
  <p class="muted">Wear red(left)/cyan(right) anaglyph glasses. Adjust clarity so the weaker eye has the clearer image.</p>

  <div class="wrap">
    <div class="left">
      <canvas id="gameCanvas" width="900" height="520"></canvas>
      <div class="hud small">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Wave: <span id="wave">1</span></div>
      </div>
    </div>

    <aside>
      <h3>Therapy Settings</h3>

      <label>Anaglyph Mode
        <input id="anaglyph" type="checkbox" checked style="margin-left:8px"/>
      </label>

      <label>Swap Channels (flip left/right)
        <input id="swap" type="checkbox" style="margin-left:8px"/>
      </label>

      <label>Left Eye Clarity: <span id="leftPct">100%</span>
        <input id="leftCl" type="range" min="0" max="1" step="0.05" value="1"/>
      </label>

      <label>Right Eye Clarity: <span id="rightPct">40%</span>
        <input id="rightCl" type="range" min="0" max="1" step="0.05" value="0.4"/>
      </label>

      <label>Difficulty (enemy speed)
        <input id="difficulty" type="range" min="0.7" max="1.6" step="0.05" value="1"/>
      </label>

      <div class="controls">
        <button id="startBtn">Start</button>
        <button id="pauseBtn" disabled>Pause</button>
        <button id="resetBtn">Reset</button>
      </div>

      <div style="margin-top:12px" class="small">
        <p><strong>Controls:</strong></p>
        <ul>
          <li>Move: ← / → or A / D</li>
          <li>Shoot: Space</li>
        </ul>
        <p>Start with short sessions (5–10 min). Stop if you feel strain/headache.</p>
      </div>
    </aside>
  </div>

<script>
(() => {
  // Canvas & contexts
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // settings UI
  const anaglyphCheckbox = document.getElementById('anaglyph');
  const swapCheckbox = document.getElementById('swap');
  const leftClSlider = document.getElementById('leftCl');
  const rightClSlider = document.getElementById('rightCl');
  const leftPct = document.getElementById('leftPct');
  const rightPct = document.getElementById('rightPct');
  const difficulty = document.getElementById('difficulty');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');

  // HUD
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const waveEl = document.getElementById('wave');

  // state
  let running = false;
  let raf = null;
  let lastTime = 0;
  let spawnTimer = 0;
  let score = 0;
  let lives = 3;
  let wave = 1;
  let enemySpeedFactor = parseFloat(difficulty.value);

  // clarity
  let leftCl = parseFloat(leftClSlider.value);
  let rightCl = parseFloat(rightClSlider.value);

  // simple player
  const player = {
    x: canvas.width/2 - 30,
    y: canvas.height - 80,
    w: 60,
    h: 18,
    speed: 360,
    cooldown: 0
  };

  const bullets = [];
  const enemies = [];

  // controls
  const keys = {};

  // helper: spawn enemy row
  function spawnWave(num=6) {
    const margin = 40;
    const spacing = (canvas.width - margin*2) / num;
    for (let i=0;i<num;i++) {
      const ex = margin + i*spacing + (spacing-40)/2;
      const ey = -40 - Math.random()*80;
      enemies.push({ x: ex, y: ey, w: 40, h: 28, hp:1, vx: 0, vy: 40 * enemySpeedFactor + Math.random()*20 });
    }
  }

  // bullets & collision
  function update(dt) {
    // player move
    if (keys['ArrowLeft'] || keys['a']) player.x -= player.speed * dt;
    if (keys['ArrowRight'] || keys['d']) player.x += player.speed * dt;
    player.x = Math.max(8, Math.min(player.x, canvas.width - player.w - 8));

    // shooting
    player.cooldown -= dt;
    if (keys[' '] && player.cooldown <= 0) {
      bullets.push({ x: player.x + player.w/2 - 3, y: player.y - 8, w:6, h:12, vy:-520 });
      player.cooldown = 0.25;
    }

    // bullets
    for (let i=bullets.length-1;i>=0;i--) {
      const b = bullets[i];
      b.y += b.vy * dt;
      if (b.y < -20) bullets.splice(i,1);
    }

    // enemies
    for (let i=enemies.length-1;i>=0;i--) {
      const e = enemies[i];
      e.y += e.vy * dt;
      // collision with player (reach bottom)
      if (e.y + e.h > canvas.height - 60) {
        enemies.splice(i,1);
        lives -= 1;
        updateHUD();
        if (lives <= 0) {
          // game over
          stopGame();
        }
        continue;
      }
      // bullet collisions
      for (let j=bullets.length-1;j>=0;j--) {
        const b = bullets[j];
        if (b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
          bullets.splice(j,1);
          e.hp -= 1;
          if (e.hp <= 0) {
            enemies.splice(i,1);
            score += 20;
            updateHUD();
          }
          break;
        }
      }
    }

    // spawn logic
    spawnTimer += dt*1000;
    if (spawnTimer > 1200 - (wave*30)) {
      spawnWave(4 + Math.min(6, wave)); // grow wave size
      spawnTimer = 0;
      wave++;
      updateHUD();
    }

    // escalate speed slowly with difficulty slider
    enemySpeedFactor = parseFloat(difficulty.value);
    enemies.forEach(e => { e.vy = 40 * enemySpeedFactor + Math.random()*20; });
  }

  // draw scene to offscreen canvas per eye
  function drawEye(ctxOff, clarity) {
    // clear
    ctxOff.clearRect(0,0,canvas.width,canvas.height);

    // starfield
    ctxOff.fillStyle = '#021018';
    ctxOff.fillRect(0,0,canvas.width,canvas.height);

    // enemies (simple shapes)
    enemies.forEach(e => {
      ctxOff.fillStyle = '#bdbdbd';
      roundRect(ctxOff, e.x, e.y, e.w, e.h, 6);
      // add detail proportional to clarity (more lines)
      const detail = 1 + Math.round(clarity * 5);
      ctxOff.fillStyle = '#333';
      for (let i=0;i<detail;i++){
        const lx = e.x + 4 + (i*(e.w-8)/Math.max(1,detail-1));
        ctxOff.fillRect(lx, e.y + 6, 2, e.h - 12);
      }
    });

    // bullets
    ctxOff.fillStyle = '#f7f7f7';
    bullets.forEach(b => ctxOff.fillRect(b.x, b.y, b.w, b.h));

    // player
    ctxOff.fillStyle = '#9be8ff';
    roundRect(ctxOff, player.x, player.y, player.w, player.h, 4);

    // HUD
    ctxOff.fillStyle = 'rgba(255,255,255,0.8)';
    ctxOff.font = '16px system-ui';
    ctxOff.fillText('Score: ' + score, 14, 22);
    ctxOff.fillText('Lives: ' + lives, 160, 22);
    ctxOff.fillText('Wave: ' + (wave-1), 260, 22);
  }

  // helper roundRect
  function roundRect(c, x, y, w, h, r) {
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
    c.fill();
  }

  function compositeToMain() {
    // create offscreen canvases for left & right
    const offL = document.createElement('canvas');
    offL.width = canvas.width; offL.height = canvas.height;
    const offR = document.createElement('canvas');
    offR.width = canvas.width; offR.height = canvas.height;
    const cL = offL.getContext('2d');
    const cR = offR.getContext('2d');

    // decide clarity values per eye respecting swap
    const swap = swapCheckbox.checked;
    const leftClarity = swap ? parseFloat(rightClSlider.value) : parseFloat(leftClSlider.value);
    const rightClarity = swap ? parseFloat(leftClSlider.value) : parseFloat(rightClSlider.value);

    // draw for each eye
    drawEye(cL, leftClarity);
    drawEye(cR, rightClarity);

    // now composite to main canvas
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if (!anaglyphCheckbox.checked) {
      ctx.globalAlpha = 1;
      ctx.drawImage(offL,0,0);
      ctx.globalAlpha = 0.6;
      ctx.drawImage(offR,0,0);
      ctx.globalAlpha = 1;
      return;
    }

    // tint and combine: left -> cyan, right -> red (standard anaglyph red-left / cyan-right mapping)
    // but using swap toggles the clarity not physical tint mapping
    // Apply tint by drawing offscreen to temporary canvas and applying a global fill with 'source-atop'
    const tmp = document.createElement('canvas'); tmp.width = canvas.width; tmp.height = canvas.height;
    const tctx = tmp.getContext('2d');

    // draw left and tint cyan with alpha tied to clarity
    tctx.clearRect(0,0,tmp.width,tmp.height);
    tctx.drawImage(offL,0,0);
    tctx.globalCompositeOperation = 'source-atop';
    tctx.fillStyle = 'rgba(0,255,255,' + leftClarity + ')';
    tctx.fillRect(0,0,tmp.width,tmp.height);
    tctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(tmp,0,0);

    // draw right and tint red
    tctx.clearRect(0,0,tmp.width,tmp.height);
    tctx.drawImage(offR,0,0);
    tctx.globalCompositeOperation = 'source-atop';
    tctx.fillStyle = 'rgba(255,0,0,' + rightClarity + ')';
    tctx.fillRect(0,0,tmp.width,tmp.height);
    tctx.globalCompositeOperation = 'source-over';

    ctx.globalCompositeOperation = 'lighter';
    ctx.drawImage(tmp,0,0);
    ctx.globalCompositeOperation = 'source-over';
  }

  function render(now) {
    const dt = lastTime ? (now - lastTime)/1000 : 0;
    lastTime = now;

    update(dt);
    compositeToMain();

    if (running) raf = requestAnimationFrame(render);
  }

  // controls & events
  window.addEventListener('keydown', (e) => {
    if (e.key === ' '){ e.preventDefault(); }
    keys[e.key] = true;
  });
  window.addEventListener('keyup', (e) => { keys[e.key] = false; });

  // UI wiring
  leftClSlider.addEventListener('input', ()=> { leftPct.textContent = Math.round(leftClSlider.value*100) + '%'; });
  rightClSlider.addEventListener('input', ()=> { rightPct.textContent = Math.round(rightClSlider.value*100) + '%'; });
  difficulty.addEventListener('input', ()=> { enemySpeedFactor = parseFloat(difficulty.value); });

  startBtn.addEventListener('click', () => {
    if (!running) startGame();
  });
  pauseBtn.addEventListener('click', () => {
    if (running) stopGame(); else startGame();
  });
  resetBtn.addEventListener('click', () => { resetGame(); });

  // start/stop/reset functions
  function startGame() {
    if (lives <= 0) { resetGame(); }
    running = true;
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    lastTime = 0;
    raf = requestAnimationFrame(render);
  }
  function stopGame() {
    running = false;
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    if (raf) cancelAnimationFrame(raf);
  }
  function resetGame() {
    stopGame();
    bullets.length = 0;
    enemies.length = 0;
    score = 0; lives = 3; wave = 1;
    player.x = canvas.width/2 - player.w/2;
    spawnTimer = 0;
    updateHUD();
    compositeToMain();
  }
  function updateHUD() {
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    waveEl.textContent = Math.max(1, wave-1);
  }

  // small loop to update collisions & apply movement (we call inside render/update)
  function updateHUDScore() {
    scoreEl.textContent = score;
  }

  // expose slider values for composite function closure
  const leftClSliderRef = leftClSlider;
  const rightClSliderRef = rightClSlider;
  // provide names used earlier
  const leftClSlider_value = () => leftClSliderRef.value;
  const rightClSlider_value = () => rightClSliderRef.value;
  // but composite uses DOM directly so it's fine

  // initial draw
  resetGame();
  compositeToMain();

})();
</script>
</body>
</html>
